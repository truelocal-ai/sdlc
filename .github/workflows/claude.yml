name: Claude Code

on:
  issue_comment:
    types: [created, edited]
  pull_request_review_comment:
    types: [created, edited]
  issues:
    types: [opened, assigned, edited]
  pull_request_review:
    types: [submitted, edited]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: self-hosted
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read

    steps:
      - name: Prepare Claude Context
        id: context
        run: |
          # Determine issue or PR number
          if [ "${{ github.event_name }}" == "issues" ]; then
            echo "NUMBER=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
            echo "TYPE=issue" >> $GITHUB_OUTPUT
            echo "BODY=${{ github.event.issue.body }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "issue_comment" ]; then
            echo "NUMBER=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
            echo "TYPE=issue" >> $GITHUB_OUTPUT
            echo "BODY=${{ github.event.comment.body }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request_review_comment" ]; then
            echo "NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "TYPE=pr" >> $GITHUB_OUTPUT
            echo "BODY=${{ github.event.comment.body }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request_review" ]; then
            echo "NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "TYPE=pr" >> $GITHUB_OUTPUT
            echo "BODY=${{ github.event.review.body }}" >> $GITHUB_OUTPUT
          fi

      - name: Prepare Claude Branch Info
        id: claude-branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.context.outputs.TYPE }}-${{ steps.context.outputs.NUMBER }}-claude"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Check if branch exists remotely using authenticated URL
          if git ls-remote --heads https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "BRANCH_EXISTS=true" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH_NAME exists remotely"
          else
            echo "BRANCH_EXISTS=false" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH_NAME does not exist, will be created"
          fi

      - name: Checkout Main Repository
        uses: actions/checkout@v5
        with:
          path: "repo"

      - name: Checkout Claude Branch
        uses: actions/checkout@v5
        with:
          path: "claude"
          ref: ${{ steps.claude-branch.outputs.BRANCH_EXISTS == 'true' && steps.claude-branch.outputs.BRANCH_NAME || null }}

      - name: Setup Branch and Claude Directory
        run: |
          # Configure git in claude directory
          cd "$GITHUB_WORKSPACE/claude"

          # Configure git for authentication
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create branch if it doesn't exist
          if [ "${{ steps.claude-branch.outputs.BRANCH_EXISTS }}" == "false" ]; then
            git checkout -b "${{ steps.claude-branch.outputs.BRANCH_NAME }}"
            echo "Created new branch ${{ steps.claude-branch.outputs.BRANCH_NAME }}"
          fi

          # Create claude subdirectory if it doesn't exist
          mkdir -p "$GITHUB_WORKSPACE/claude/claude"

          # Debug: Find the actual host path for Docker mounts
          echo "=== Investigating mount paths for Docker-in-Docker ==="
          echo "Current path: $(pwd)"
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          df -h "$GITHUB_WORKSPACE" | tail -1
          mount | grep "$GITHUB_WORKSPACE" || echo "No direct mount found"

          # Check if we can find the host path
          if docker ps >/dev/null 2>&1; then
            SELF_CONTAINER_ID=$(basename $(cat /proc/1/cpuset))
            echo "Self container ID: $SELF_CONTAINER_ID"
            docker inspect "$SELF_CONTAINER_ID" 2>/dev/null | grep -A 5 "Mounts" || echo "Cannot inspect self"
          fi

      - name: Run Claude Code in Container
        id: claude_run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.context.outputs.NUMBER }}
          ISSUE_TYPE: ${{ steps.context.outputs.TYPE }}
        run: |
          # Create prompts as files
          cat > "$GITHUB_WORKSPACE/repo/.claude-user-prompt.txt" << 'EOF'
          You are working on ${{ steps.context.outputs.TYPE }} #${{ steps.context.outputs.NUMBER }} in repository ${{ github.repository }}.

          User request: ${{ steps.context.outputs.BODY }}
          EOF
          sed -i 's/@claude//g' "$GITHUB_WORKSPACE/repo/.claude-user-prompt.txt"

          cp "$GITHUB_WORKSPACE/repo/.github/claude-system-prompt.md" "$GITHUB_WORKSPACE/repo/.claude-system-prompt.txt"

          # For self-hosted runners, the workspace path is typically the same on host and in runner
          # Try mounting directly with the current path
          echo "=== Running Claude Code ==="
          echo "Mounting: $GITHUB_WORKSPACE/repo -> /workspace"

          set +e
          docker run --rm \
            -v "$GITHUB_WORKSPACE/repo:/workspace" \
            -v "$GITHUB_WORKSPACE/claude/claude:/home/claude/.claude/projects/-workspace" \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -e CLAUDE_CODE_OAUTH_TOKEN="${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" \
            -e GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}" \
            sdlc-claude:latest \
            2>&1 | tee "$GITHUB_WORKSPACE/claude-output.txt"

          CLAUDE_EXIT_CODE=${PIPESTATUS[0]}
          set -e

          echo "Claude Code exit code: $CLAUDE_EXIT_CODE"
          echo "OUTPUT_FILE=$GITHUB_WORKSPACE/claude-output.txt" >> $GITHUB_OUTPUT

      - name: Commit and Push Claude State Changes
        run: |
          cd "$GITHUB_WORKSPACE/claude"

          # Check if there are changes to commit (Claude project state)
          if [[ -n $(git status -s) ]]; then
            git add .
            git commit -m "Claude Code state: ${{ steps.context.outputs.TYPE }} #${{ steps.context.outputs.NUMBER }}"

            # Configure git to use token for push
            git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
            git push -u origin "${{ steps.claude-branch.outputs.BRANCH_NAME }}"
            echo "Claude state committed and pushed to branch ${{ steps.claude-branch.outputs.BRANCH_NAME }}"
          else
            echo "No Claude state changes to commit"
          fi

      - name: Post Claude Response as Comment
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if output file exists and has content
          if [ ! -f "$GITHUB_WORKSPACE/claude-output.txt" ] || [ ! -s "$GITHUB_WORKSPACE/claude-output.txt" ]; then
            echo "No output file found or file is empty. Creating error message."
            echo "Error: Claude Code did not produce any output. Check the workflow logs for details." > "$GITHUB_WORKSPACE/claude-output.txt"
          fi

          # Read the output and escape for JSON
          CLAUDE_OUTPUT=$(cat "$GITHUB_WORKSPACE/claude-output.txt")

          # Create formatted comment with code block
          COMMENT_BODY="## Claude Code Response

          \`\`\`
          ${CLAUDE_OUTPUT}
          \`\`\`

          ---
          *Triggered by @${{ github.actor }} on ${{ steps.context.outputs.TYPE }} #${{ steps.context.outputs.NUMBER }}*"

          # Escape for JSON using jq
          JSON_BODY=$(jq -n --arg body "$COMMENT_BODY" '{body: $body}')

          # Post comment using GitHub API
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ steps.context.outputs.NUMBER }}/comments" \
            -d "$JSON_BODY"
